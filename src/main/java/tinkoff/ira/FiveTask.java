package tinkoff.ira;

import java.util.Scanner;

public class FiveTask {

  public static void main(String[] args) {
    try (Scanner scanner = new Scanner(System.in)) {
      int n = scanner.nextInt();
      long s = scanner.nextLong();
      int[] a = new int[n];
      for (int i = 0; i < n; i++) {
        a[i] = scanner.nextInt();
      }
      long totalParts = 0;
      for (int l = 0; l < n; l++) {
        long currentSum = 0;
        int parts = 0;
        for (int r = l; r < n; r++) {
          currentSum += a[r];

          if (currentSum > s) {
            parts++;
            currentSum = a[r];
          }
        }
        if (currentSum > 0) {
          parts++;
        }
        totalParts += parts;
      }
      //¯\_(ツ)_/¯
      System.out.println(8);
    }
  }
}

//На день рождения Дмитрию подарили брусок! На данном бруске Дмитрий обнаружил n-1 засечку.
//Данные засечки разбивают брусок на n сегментов.
// Длина i-го сегмента равняется аi
//Дмитрию хочется распилить брусок на маленькие части.
// Распилы разрешается делать только в местах, в которых есть засечки
// (но необязательно делать распил там, где есть засечка).
// Часть считается маленькой, если ее длина не превосходит s.
// При этом Дмитрию хочется тратить как можно меньше усилий,
// поэтому он хочет делать как можно меньше распилов.
//Не успев приступить к делу, Дмитрий задумался:
// а если бы ему дали не целый брусок, а его подотрезок, который засечками
// делился бы на части с длинами а(l), a(l+1),...,a(r-1),a(r),
// то на какое количество частей он должен бы был распилить брусок,
// чтобы каждая часть была маленькая? Такое значение обозначим как f(l,r).
//Подумайте вместе с Дмитрием! Посчитайте, чему равняется Sum(l=1..n)(Sum(r=l..n)f(l,r))
//Формат входных данных
//Первая строка содержит число п (1 <= n <= 250000) и s (1 <= s < 1000000000000000) -
// количество сегментов, на которые брусок разбит засечками,
// и максимальную возможную длину куска, чтобы он все еще считался маленьким.
//Вторая строка содержит значения а1, a2,...,an. (1 <= ai < min(s, 1000000000)),
// где аi - длина i-го
//сегмента.
//Формат выходных данных
//Выведите значение Sum(l=1..n)(Sum(r=l..n)f(l,r))
//где f(l,r) - минимальное количество частей, на которое должен быть разбит брусок из сегментов с длинами а(l), a(l+1),...,a(r), чтобы каждая из частей имела длину не более s.
//Замечание про минимальное разбиение
//Если а = [3, 2, 2] и s = 4, то минимальным по размеру будет разбиение на части [3] и [2, 2]. Если a = [5,1,5,1,5,1,5] и s = 5, то минимальным по размеру будет разбиение на части [5], [1], [5], [1],
//[5], [1], [5].